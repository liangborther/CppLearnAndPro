# Cpp面试经验分享

#### 1.是否了解git，用过哪些git命令

+ Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本的更改。
  与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。
  每个开发人员都可以“克隆”我在图中用“Local repository”标注的存储库的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要的所有恢复数据都在你队友的本地 Git 存储库中。
  还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享，如图所示，所有协作者都在提交更改“远程存储库”。

#### 2.git有哪些特点，你在项目中是怎么用的

1. 分布式版本控制：即每个开发者都有一个完整的本地仓库，包含了项目的所有历史记录
2. 高效的数据存储：使用快照存储，并且进行了压缩
3. 强大的分支和合并功能
4. 灵活的流程控制
5. **初始化仓库** ：

   * 使用 `git init` 命令在项目根目录下初始化一个新的 Git 仓库。
6. **配置用户信息** ：

   * 使用 `git config --global user.name "Your Name"` 和 `git config --global user.email "your.email@example.com"` 配置全局用户信息。
7. **添加文件和提交更改** ：

   * 使用 `git add .` 或 `git add <filename>` 将新文件或修改过的文件添加到暂存区。
   * 使用 `git commit -m "Commit message"` 提交更改到本地仓库，并附上提交信息。
8. **创建和切换分支** ：

   * 使用 `git branch <branchname>` 创建新分支。
   * 使用 `git checkout <branchname>` 或 `git switch <branchname>`（Git 2.23+）切换分支。
9. **推送和拉取** ：

   * 使用 `git push origin <branchname>` 将本地分支的更改推送到远程仓库。
   * 使用 `git pull origin <branchname>` 或 `git fetch origin <branchname>` 后 `git merge origin/<branchname>` 从远程仓库拉取并合并更改。
10. **解决合并冲突** ：

    * 当合并分支时发生冲突，Git 会暂停合并过程并提示解决冲突。我通常会手动编辑冲突文件，解决冲突后使用 `git add <filename>` 标记为已解决，然后继续合并操作。
11. **使用标签** ：

    * 使用 `git tag <tagname>` 创建标签，以标记项目中的重要里程碑，如发布版本。
12. **使用 Git 钩子** ：

    * 在项目根目录下的 `.git/hooks` 文件夹中，可以放置自定义的脚本来自动化某些 Git 操作，如提交前检查代码风格等。

#### 3.说说linux中你最不常用的两个命令，并解释他们的作用

##### 1. mktemp

**作用** ：
`mktemp`命令用于在`/tmp`目录下创建一个唯一的临时文件或目录，防止在创建临时文件或目录时发生名称冲突。这对于需要处理大量临时数据的脚本和程序特别有用。

**用法示例** ：

* 创建一个临时文件：`mktemp mytempfile.XXXXXX`（`XXXXXX`将被替换为随机字符，确保文件名的唯一性）。
* 创建一个临时目录：`mktemp -d mytempdir.XXXXXX`（`-d`选项表示创建一个目录而不是文件）。

##### 2. ltrace

**作用** ：
`ltrace`是一个用于跟踪程序执行过程中调用的库函数的工具。它类似于`strace`，但`strace`跟踪的是系统调用，而`ltrace`跟踪的是库函数调用。这对于分析程序行为、调试和性能优化非常有用，特别是当需要了解程序在运行时如何与库交互时。

**用法示例** ：

* 跟踪某个程序的所有库函数调用：`ltrace ./myprogram`（这将列出`myprogram`执行期间调用的所有库函数及其参数）。
* 使用过滤器仅跟踪特定函数：`ltrace -e 'malloc|free' ./myprogram`（这将仅列出`myprogram`执行期间调用`malloc`和`free`函数的情况）。

#### 4.说说常见的内存泄漏有哪些

##### 1. 未释放的堆内存

* **描述** ：C++中，堆内存是通过`new`或`new[]`操作符动态分配的，当不再需要时，应当使用`delete`或`delete[]`来释放。如果忘记释放或因为逻辑错误未释放，就会导致内存泄漏。
* **示例** ：分配内存后未释放，或者只在某些条件下释放内存。

##### 2. 析构函数中未匹配地释放内存

* **描述** ：在类的析构函数中，如果负责释放堆内存的代码由于某种原因（如条件判断错误）未执行，将导致内存泄漏。
* **示例** ：析构函数中有未执行的释放内存代码段。

##### 3. 基类析构函数未设为虚函数

* **描述** ：当基类指针指向派生类对象，并通过基类指针`delete`时，如果基类的析构函数不是虚函数，那么将只调用基类的析构函数，派生类的析构函数不会被调用，导致派生类部分内存未释放。
* **示例** ：基类析构函数未声明为`virtual`，派生类对象通过基类指针被删除。

##### 4. 指针数组释放不彻底

* **描述** ：对于动态分配的指针数组，如二维数组，如果只释放了数组本身而未释放数组中的每个指针指向的内存，会导致内存泄漏。
* **示例** ：使用`new`分配了二维数组，但只使用了`delete[]`释放了数组的第一个维度。

##### 5. 缺少拷贝构造函数和赋值运算符的重载

* **描述** ：当类中含有指针成员时，如果未定义拷贝构造函数和赋值运算符，编译器将自动生成浅拷贝版本的这两个函数。这可能导致两个对象中的指针成员指向同一块内存，从而在析构时释放同一块内存两次（如果析构函数中有释放内存的代码），或者造成内存泄漏（如果其中一个对象在另一个对象之前被销毁，且析构函数中未释放内存）。
* **示例** ：含有指针成员的类未提供适当的拷贝构造函数和赋值运算符重载。

##### 6. 循环引用

* **描述** ：在面向对象编程中，两个或多个对象相互持有对方的引用（例如，通过智能指针`shared_ptr`），且这些引用形成了一个闭环。这将导致这些对象无法被垃圾回收器正常回收，因为它们都在等待对方被销毁。
* **示例** ：两个类通过`shared_ptr`相互引用对方，导致双方都无法被销毁。

##### 7. 缓存未清理

* **描述** ：程序中使用缓存来提高性能，但如果缓存策略不当，如未清理过期或无用的数据，将导致内存占用不断增加，从而引发内存泄漏。
* **示例** ：缓存机制未设置过期时间或未定期清理缓存数据。

##### 8. 事件监听未取消

* **描述** ：在事件驱动的编程模型中，如果注册了事件监听器但未在不再需要时取消注册，这些监听器将继续持有对对象的引用，导致对象无法被垃圾回收。
* **示例** ：注册了事件监听器但未在组件销毁时取消注册。

##### 9. 线程未正确终止

* **描述** ：多线程编程中，如果线程未正确终止，其占用的资源（包括内存）可能无法被释放。
* **示例** ：线程创建后未调用适当的函数来终止线程，或者线程在异常情况下终止。

##### 10. 异常处理不当

* **描述** ：在异常处理过程中，如果未正确清理异常发生时创建的对象或资源，将导致内存泄漏。
* **示例** ：在catch块中未释放new分配的内存。

#### 5.有没有自动防止内存泄漏的东西

##### 1. 智能指针

智能指针是C++中一种非常重要的特性，它们能够自动管理内存，减少内存泄漏的风险。常见的智能指针包括：

* **std::unique_ptr** ：这是一种独占性智能指针，保证同一时间内只有一个unique_ptr指向某个对象。当unique_ptr被销毁时，它所指向的对象也会被自动删除。
* **std::shared_ptr** ：允许多个shared_ptr实例共享对同一个对象的所有权。只有当最后一个shared_ptr被销毁时，对象才会被删除。shared_ptr使用引用计数来跟踪有多少个shared_ptr指向一个对象。
* **std::weak_ptr** ：与shared_ptr配合使用，但它不增加对象的引用计数。weak_ptr主要用于解决shared_ptr之间的循环引用问题。

智能指针通过封装原始指针，并在其析构函数中自动释放所管理的内存，从而避免了手动释放内存时可能出现的错误。

##### 2. 资源获取即初始化（RAII）

RAII是一种在C++中广泛使用的资源管理技术。它的基本思想是将资源的生命周期与对象的生命周期绑定在一起。在对象构造时获取资源，在对象析构时释放资源。这样，当对象的作用域结束时，其析构函数会自动被调用，从而释放所管理的资源。

##### 3. 容器类

C++标准库提供了一系列容器类，如std::vector、std::list、std::map等。这些容器类都自动管理其内部元素的内存。当容器被销毁时，它会释放所有内部元素的内存。因此，使用容器类可以大大降低内存泄漏的风险。

##### 4. 内存泄漏检测工具

除了上述编程技术外，还有一些内存泄漏检测工具可以帮助开发者发现和修复内存泄漏问题。这些工具通常会在程序运行时监控内存的使用情况，并报告任何潜在的内存泄漏。常见的内存泄漏检测工具包括：

* **Valgrind** ：一个开源的内存调试和性能分析工具，其中的memcheck工具可以检测内存泄漏问题。
* **AddressSanitizer (ASan)** ：LLVM/Clang编译器提供的一种内存错误检测工具，可以检测内存泄漏、缓冲区溢出等问题。
* **LeakSanitizer (LSan)** ：与ASan类似，但专门用于检测内存泄漏问题。
* **Visual Leak Detector** ：一个Windows平台下的内存泄漏检测工具，可以在Visual Studio中使用。
