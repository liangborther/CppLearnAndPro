# C++ 单例模式

## 一、单例模式

通过单例模式创建出来的类，在当前进程中只有一个实例

## 二、应用场景

* 配置管理
* 日志记录
* 线程池
* 连接池
* 内存池
* 对象池
* 消息队列

类似统一的资源管理

## 三、实现步骤

1. 将类的构造方法定义为私有方法
2. 定义一个私有类的静态实例
3. 提供一个公有的获取实例的静态方法

# 装饰器模式

## 一、介绍

装饰器（Decorator）模式是一种结构型设计模式，它允许你动态地给一个对象添加额外的职责。

装饰器模式主要用于扩展对象的功能，而又不改变其原有结构。在C++中，装饰器模式主要应用于那些需要为对象动态添加功能或改变行为的场景，而这些附加行为是可以独立于基础组件的。
装饰器模式通常包含以下几个组件：

（1）组件（Component）：定义一个对象接口，可以给这些对象动态地添加职责。

（2）具体组件（ConcreteComponent）：实现组件接口，是被装饰器装饰的对象。

（3）装饰器（Decorator）：实现与组件相同的接口，它包含一个指向组件对象的指针（或者引用），并可以在调用组件的方法之前或之后添加一些额外的功能。

（4）具体装饰器（ConcreteDecorator）：实现装饰器接口，并添加一些额外的职责。

## 二、装饰器模式优缺点

优点：

灵活性：装饰器模式允许动态地给对象添加功能，而且可以根据需要多次进行装饰，从而实现各种组合方式，使得功能扩展变得非常灵活。
开闭原则：装饰器模式符合开闭原则，可以在不修改现有代码的情况下，增加新的功能。
缺点：

复杂性：装饰器模式引入了许多小的对象和类，可能会导致系统中对象数量的增加，从而增加系统的复杂性。
容易出错：由于装饰器模式允许灵活地组合对象，因此在设计时需要特别小心，以避免出现过度复杂或混乱的装饰器组合，导致难以理解和维护的问题。

# 工厂模式

## 一、介绍

工厂模式的定义：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。这满足创建型模式中所要求的“创建与使用相分离”的特点。

按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是[简单工厂模式](https://so.csdn.net/so/search?q=%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020)、工厂方法模式和抽象工厂模式。

### 1.简单工厂模式

在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。

简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。

“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。

### 2.简单工厂模式的优缺点

优点：

工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
客户端无需知道所创建具体产品的类名，只需知道参数即可。
也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。
缺点：

简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。
使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度
系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂
简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。
应用场景

对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。
