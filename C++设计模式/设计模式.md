# C++ 单例模式

## 一、单例模式

通过单例模式创建出来的类，在当前进程中只有一个实例

## 二、应用场景

* 配置管理
* 日志记录
* 线程池
* 连接池
* 内存池
* 对象池
* 消息队列

类似统一的资源管理

## 三、实现步骤

1. 将类的构造方法定义为私有方法
2. 定义一个私有类的静态实例
3. 提供一个公有的获取实例的静态方法

# 装饰器模式

## 一、介绍

装饰器（Decorator）模式是一种结构型设计模式，它允许你动态地给一个对象添加额外的职责。

装饰器模式主要用于扩展对象的功能，而又不改变其原有结构。在C++中，装饰器模式主要应用于那些需要为对象动态添加功能或改变行为的场景，而这些附加行为是可以独立于基础组件的。
装饰器模式通常包含以下几个组件：

（1）组件（Component）：定义一个对象接口，可以给这些对象动态地添加职责。

（2）具体组件（ConcreteComponent）：实现组件接口，是被装饰器装饰的对象。

（3）装饰器（Decorator）：实现与组件相同的接口，它包含一个指向组件对象的指针（或者引用），并可以在调用组件的方法之前或之后添加一些额外的功能。

（4）具体装饰器（ConcreteDecorator）：实现装饰器接口，并添加一些额外的职责。


## 二、装饰器模式优缺点

优点：

灵活性：装饰器模式允许动态地给对象添加功能，而且可以根据需要多次进行装饰，从而实现各种组合方式，使得功能扩展变得非常灵活。
开闭原则：装饰器模式符合开闭原则，可以在不修改现有代码的情况下，增加新的功能。
缺点：

复杂性：装饰器模式引入了许多小的对象和类，可能会导致系统中对象数量的增加，从而增加系统的复杂性。
容易出错：由于装饰器模式允许灵活地组合对象，因此在设计时需要特别小心，以避免出现过度复杂或混乱的装饰器组合，导致难以理解和维护的问题。

# 工厂模式

## 一、介绍
